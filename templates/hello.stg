/*
This is a comment
This is a very simple template with just one attribute substitution
The template is declared with hello(audience) ::=...
The name of the template is hello and it must match the name of the file.
The arguments that the template expects are given in ( ) after the name.
All the text within << >>> is the body of the template.
Within the template body text between $$ are template expressions.
Everything else is literal text to include in the output.
$audience;null="is anyone there?"$ is an attribute expression with the null option.
This substitutes the value of the data attribute named audience and if that value is not present or null then
the null option provides an alternative value.
Try this template with these commands:
    stst hello hello.json
    stst hello hello_empty.json
	
Note that both args seem to be pulled by name from the JSON file!
I think what is going on is the top-level attribute names from the object in the JSON
file are set by name as the params to the top level template.  The order in the JSON document
seems not to matter.
*/
hello(audience,audience2) ::= <<Say $audience.a.x$ Hello $audience2:{x | $bracket(x,"2")$};null="is anyone there?"$!$!this is the syntax for a comment inside a template!$
>>

bracket(name,number) ::= <<[$name$#$number$]>>
